;;;; Hilfsfunktionen


;;;;Mergesort
(defun mergesort (a)
  (setq m (length a))
  (if (equal m 1) (return a)
   (progn 
     (let* ((half (floor (/ m 2)))
           (aLeft (mergesort (subseq  a 0 half)))
           (aRight (mergesort (subseq a half m))))
       (merge-lists aLeft aRight)))))


(defun merge-lists (aLeft aRight)
  (let* ((size (+ (length aLeft) (length aRight)))
         (b (make-array size :fill-pointer 0)))
    (loop for x from 0 to size do
          (let ((x (car aLeft))(y (car aRight))) ;get first elem
            (when (and (not (equal nil x)) (not (equal nil y)))
              (if (<= x y) 
                  (progn (setq aLeft (cdr aLeft)) ;set list to rest
                    (vector-push x b)) ;add smaller list item ro sorted list
                (progn (setq aRight (cdr aRight))
                  (vector-push y b)))))) ;add smaller list item ro sorted list
(mapcar (lambda (x) (vector-push x b)) (append aLeft aRight)) ;one of the lists has to be empty (x or y nil) --> this is the rest
(coerce b 'list)))

;;;---------------------------------------------------------------------------------------------------------------------------------List Functions for boolean Queries


;entspricht AND
(defun intersect (p1 p2)
  (let ((answer '()))
    (loop while (and (not (equal p1 nil)) (not (equal p2 nil))) do
          (cond ((equal (car p1) (car p2))
                 (setq answer (append answer (list (car p1))))
                 (setq p1 (cdr p1))
                 (setq p2 (cdr p2)))
                ((< (car p1) (car p2)) (setq p1 (cdr p1)))
                (t (setq p2 (cdr p2))))) answer))

;entspricht OR
(defun unionLists (p1 p2)
  (let ((answer '()))
    (loop while (and (not (equal p1 nil)) (not (equal p2 nil))) do
          (cond ((equal (car p1) (car p2)) ;no doubles
                 (setq answer (append answer (list (car p1))))
                 (setq p1 (cdr p1))
                 (setq p2 (cdr p2)))
                ((< (car p1) (car p2)) (setq answer (append answer (list (car p1)))) (setq p1 (cdr p1)))
                (t (setq answer (append answer (list (car p2)))) (setq p2 (cdr p2)))))
    (mapcar (lambda (x) (setq answer (append answer (list x)))) (append p1 p2)) answer))


;ACHTUNG: Die Term-Liste muss zuvor nach aufsteigender Term-Frequency sortiert worden sein!! Hier Annahme: Auswetung des jeweiligen terms liefert die Postings-Liste
(defun intersectConjunctive (termList)
  (let ((result (eval (car termList))) (terms (cdr termList)))
    (loop while (and (not (equal terms nil)) (not (equal result nil))) do
          (setq result (intersect result (eval (car terms)))) ;die kleinste/erste posting list nacheinander mit allen restlichen intersecten
          (setq terms (cdr terms))) result))



          




     
    
;;;;--------------------------------------------------------------


(mergesort '(7 834 234 124 46 203i4 -1))

(setq a '(1 34 345 900))
(setq b '(34 50 900 12321))
(setq c '(30))


(intersect a b)


(intersectConjunctive '(a b c))

(merge-lists (merge-lists a b) c)

(union (union a b) c)