;;;;InititalSetup

(defvar *keyword-dict* (make-hash-table :test 'equalp)) ;key is term, value is posting list with doc-ID and type and content
(defvar *documents*) ;key is docID, value is tuple (docPath docVector)
(defvar *free-text* '())
(defvar *results* '())


(defstruct document path document-vector datum absender)
(defstruct term index idf)
(defstruct keyword-entry doc-id keyword-type content)






(defun readFileInLines (dateiname) 
  (if (probe-file dateiname)
      (do* ((streamin (open dateiname))
            (currentLine (read-line streamin nil 'eof) (read-line streamin nil 'eof))
            (lineSet nil))
           ((equal currentLine'eof) (close streamin) (nreverse lineSet))
        (setq lineSet (cons currentLine lineSet)))
    nil))




(defun split(expr-list)
  (let ((keywords-list '()) (free-text '()) (stack '()))
    (mapcar (lambda (x) 
              (if ( > (length x) 0) 
                  (cond ((and (equal (char x 0) '#\() (equal (char x (- (length x) 1)) '#\)))
                         (setq keywords-list (cons x keywords-list))) ;add keyword
                        ((and (equal (char x 0) '#\() (really-opening x))
                         (setq stack (cons x stack))) ;start of keyword over multiple lines, add to stack
                        ((> (length stack) 0) ;unfinished keyword on stack?
                         (if (and (equal (char x (- (length x) 1)) '#\)) (really-closing x)) 
                             (progn 
                               (setq keywords-list (cons (merge-multiple-line-keyword stack x) keywords-list))
                               (setq stack '())) ;keyword closing, merge stacked lines and add complete keyword
                           (setq stack (cons x stack)))) ;not closing yet, add to stack
                        (t (setq free-text (cons x free-text))))))  ;free text
            expr-list) 
    (list (nreverse keywords-list) (nreverse free-text))))




(defun merge-multiple-line-keyword (stack curr)
  (let ((expr curr))
    (mapcar (lambda (x)
              (setq expr (concatenate 'string x expr))) stack)
    expr))



;check if ")" is left over 
(defun really-closing (x) 
  (let ((numberOpening (count '#\( x :test #'equal)) (numberClosing (count '#\) x :test #'equal)))
    (equal 1 (- numberClosing numberOpening))))



;check if "(" is left over 
(defun really-opening (x) 
  (let ((numberOpening (count '#\( x :test #'equal)) (numberClosing (count '#\) x :test #'equal)))
    (equal 1 (- numberOpening numberClosing))))
   


(defun split-name-content (str)
  (let ((key-name) (key-content) (j))
    (cond ((> (length str) 0)
           (setq j (position #\Space str :start 0))
           (setq key-name (subseq str 0 j))
           (setq key-content (subseq str j (length str)))
           (list key-name key-content)))))




(defun createDocumentDictionary(directory-name)
  (let ((id 0))
    (setq *documents* (make-hash-table))
    (mapcar (lambda (x) 
              (setf (gethash id *documents*) 
                    (make-document 
                     :path x 
                     :document-vector nil))
              (setq id (+ 1 id)))
            (directory directory-name))))(defvar *keyword-dict* (make-hash-table :test 'equalp)) ;key is term, value is posting list with doc-ID and type and content
(defvar *documents*) ;key is docID, value is tuple (docPath docVector)
(defvar *free-text* '())
(defvar *results* '())


(defstruct document path document-vector datum absender)
(defstruct term index idf)
(defstruct keyword-entry doc-id keyword-type content)






(defun readFileInLines (dateiname) 
  (if (probe-file dateiname)
      (do* ((streamin (open dateiname))
            (currentLine (read-line streamin nil 'eof) (read-line streamin nil 'eof))
            (lineSet nil))
           ((equal currentLine'eof) (close streamin) (nreverse lineSet))
        (setq lineSet (cons currentLine lineSet)))
    nil))




(defun split(expr-list)
  (let ((keywords-list '()) (free-text '()) (stack '()))
    (mapcar (lambda (x) 
              (if ( > (length x) 0) 
                  (cond ((and (equal (char x 0) '#\() (equal (char x (- (length x) 1)) '#\)))
                         (setq keywords-list (cons x keywords-list))) ;add keyword
                        ((and (equal (char x 0) '#\() (really-opening x))
                         (setq stack (cons x stack))) ;start of keyword over multiple lines, add to stack
                        ((> (length stack) 0) ;unfinished keyword on stack?
                         (if (and (equal (char x (- (length x) 1)) '#\)) (really-closing x)) 
                             (progn 
                               (setq keywords-list (cons (merge-multiple-line-keyword stack x) keywords-list))
                               (setq stack '())) ;keyword closing, merge stacked lines and add complete keyword
                           (setq stack (cons x stack)))) ;not closing yet, add to stack
                        (t (setq free-text (cons x free-text))))))  ;free text
            expr-list) 
    (list (nreverse keywords-list) (nreverse free-text))))




(defun merge-multiple-line-keyword (stack curr)
  (let ((expr curr))
    (mapcar (lambda (x)
              (setq expr (concatenate 'string x expr))) stack)
    expr))



;check if ")" is left over 
(defun really-closing (x) 
  (let ((numberOpening (count '#\( x :test #'equal)) (numberClosing (count '#\) x :test #'equal)))
    (equal 1 (- numberClosing numberOpening))))



;check if "(" is left over 
(defun really-opening (x) 
  (let ((numberOpening (count '#\( x :test #'equal)) (numberClosing (count '#\) x :test #'equal)))
    (equal 1 (- numberOpening numberClosing))))
   


(defun split-name-content (str)
  (let ((key-name) (key-content) (j))
    (cond ((> (length str) 0)
           (setq j (position #\Space str :start 0))
           (setq key-name (subseq str 0 j))
           (setq key-content (subseq str j (length str)))
           (list key-name key-content)))))




(defun createDocumentDictionary(directory-name)
  (let ((id 0))
    (setq *documents* (make-hash-table))
    (mapcar (lambda (x) 
              (setf (gethash id *documents*) 
                    (make-document 
                     :path x 
                     :document-vector nil))
              (setq id (+ 1 id)))
            (directory directory-name))))



;form: dictionary mit keywords mit dem keyword-namen [symbol] als key und entries in der form (docID type content)
(defun process-keyword-list (keyword-list docID)
  (let ((current) (key) (entry) (type) (content))
    (do* ((k-list keyword-list (cdr k-list))
          (k (car k-list) (car k-list))) ;iterate over keyword list, k is the whole term!
         ((equal k-list nil) nil)
      (setq k (subseq k 1 (- (length k) 1))) ;dont want the brackets
      
      (setq current (split-name-content k)) 
      (setq key (read-from-string (first current)))
      (setq content (read-from-string (second current)))
      (setq type (type-of content))



      (cond ((equalp key 'datum) 
             (setf (document-datum (gethash docID *documents*)) content))
            ((equalp key 'absender) 
             (setf (document-absender (gethash docID *documents*)) content)))  
      (setq entry 
            (make-keyword-entry 
             :doc-id docID 
             :keyword-type type 
             :content content)) 
      (if (gethash key *keyword-dict*)
          (setf (gethash key *keyword-dict*) (cons entry (gethash key *keyword-dict*))) ;already existing ;HIER sortiert einfuegen
        (setf (gethash key *keyword-dict*) (list entry)))))) ;new entry for keyword



;returns all keys from  dictionary sorted alphabetically (+ freitext as special keyword)
(defun getKeys (dict)
  (let ((keylist '()))
    (loop for key being the hash-key of dict do 
          (setq keylist (cons key keylist)))
    (cons 'FREITEXT (sort keylist 'string<))))



(defun sort-keyword-list()
  (let ((entry-list))
    (loop for key being the hash-key of *keyword-dict* do
          (setq entry-list (gethash key *keyword-dict*))
          (stable-sort entry-list #'(lambda (x y)
                       (< (keyword-entry-doc-id x) (keyword-entry-doc-id y)))))))




;has to do all init steps, called when directory selected
(defun onSelected (directory-name)
  (let ((current-doc))
    (setf (capi:button-enabled select-button) nil)
    (setq *results* '()) ;reset results because new directory
    (createDocumentDictionary directory-name)
    (loop for docID being the hash-key of *documents* do 
          (setq current-doc (split (readFileInLines (document-path (gethash docID *documents*)))))
          (process-keyword-list (first current-doc) docID)
          (setq *free-text* (cons (list docID (second current-doc)) *free-text*))
          (add-to-vocabulary (second current-doc)))
    (sort-keyword-list)
    (create-term-dictionary)
    (create-document-vectors *free-text*)
    (getKeys *keyword-dict*)))






;form: dictionary mit keywords mit dem keyword-namen [symbol] als key und entries in der form (docID type content)
(defun process-keyword-list (keyword-list docID)
  (let ((current) (key) (entry) (type) (content))
    (do* ((k-list keyword-list (cdr k-list))
          (k (car k-list) (car k-list))) ;iterate over keyword list, k is the whole term!
         ((equal k-list nil) nil)
      (setq k (subseq k 1 (- (length k) 1))) ;dont want the brackets
      
      (setq current (split-name-content k)) 
      (setq key (read-from-string (first current)))
      (setq content (read-from-string (second current)))
      (setq type (type-of content))



      (cond ((equalp key 'datum) 
             (setf (document-datum (gethash docID *documents*)) content))
            ((equalp key 'absender) 
             (setf (document-absender (gethash docID *documents*)) content)))  
      (setq entry 
            (make-keyword-entry 
             :doc-id docID 
             :keyword-type type 
             :content content)) 
      (if (gethash key *keyword-dict*)
          (setf (gethash key *keyword-dict*) (cons entry (gethash key *keyword-dict*))) ;already existing ;HIER sortiert einfuegen
        (setf (gethash key *keyword-dict*) (list entry)))))) ;new entry for keyword



;returns all keys from  dictionary sorted alphabetically (+ freitext as special keyword)
(defun getKeys (dict)
  (let ((keylist '()))
    (loop for key being the hash-key of dict do 
          (setq keylist (cons key keylist)))
    (cons 'FREITEXT (sort keylist 'string<))))



(defun sort-keyword-list()
  (let ((entry-list))
    (loop for key being the hash-key of *keyword-dict* do
          (setq entry-list (gethash key *keyword-dict*))
          (stable-sort entry-list #'(lambda (x y)
                       (< (keyword-entry-doc-id x) (keyword-entry-doc-id y)))))))




;has to do all init steps, called when directory selected
(defun onSelected (directory-name)(defvar *keyword-dict* (make-hash-table :test 'equalp)) ;key is term, value is posting list with doc-ID and type and content
(defvar *documents*) ;key is docID, value is tuple (docPath docVector)
(defvar *free-text* '())
(defvar *results* '())


(defstruct document path document-vector datum absender)
(defstruct term index idf)
(defstruct keyword-entry doc-id keyword-type content)






(defun readFileInLines (dateiname) 
  (if (probe-file dateiname)
      (do* ((streamin (open dateiname))
            (currentLine (read-line streamin nil 'eof) (read-line streamin nil 'eof))
            (lineSet nil))
           ((equal currentLine'eof) (close streamin) (nreverse lineSet))
        (setq lineSet (cons currentLine lineSet)))
    nil))




(defun split(expr-list)
  (let ((keywords-list '()) (free-text '()) (stack '()))
    (mapcar (lambda (x) 
              (if ( > (length x) 0) 
                  (cond ((and (equal (char x 0) '#\() (equal (char x (- (length x) 1)) '#\)))
                         (setq keywords-list (cons x keywords-list))) ;add keyword
                        ((and (equal (char x 0) '#\() (really-opening x))
                         (setq stack (cons x stack))) ;start of keyword over multiple lines, add to stack
                        ((> (length stack) 0) ;unfinished keyword on stack?
                         (if (and (equal (char x (- (length x) 1)) '#\)) (really-closing x)) 
                             (progn 
                               (setq keywords-list (cons (merge-multiple-line-keyword stack x) keywords-list))
                               (setq stack '())) ;keyword closing, merge stacked lines and add complete keyword
                           (setq stack (cons x stack)))) ;not closing yet, add to stack
                        (t (setq free-text (cons x free-text))))))  ;free text
            expr-list) 
    (list (nreverse keywords-list) (nreverse free-text))))




(defun merge-multiple-line-keyword (stack curr)
  (let ((expr curr))
    (mapcar (lambda (x)
              (setq expr (concatenate 'string x expr))) stack)
    expr))



;check if ")" is left over 
(defun really-closing (x) 
  (let ((numberOpening (count '#\( x :test #'equal)) (numberClosing (count '#\) x :test #'equal)))
    (equal 1 (- numberClosing numberOpening))))



;check if "(" is left over 
(defun really-opening (x) 
  (let ((numberOpening (count '#\( x :test #'equal)) (numberClosing (count '#\) x :test #'equal)))
    (equal 1 (- numberOpening numberClosing))))
   


(defun split-name-content (str)
  (let ((key-name) (key-content) (j))
    (cond ((> (length str) 0)
           (setq j (position #\Space str :start 0))
           (setq key-name (subseq str 0 j))
           (setq key-content (subseq str j (length str)))
           (list key-name key-content)))))




(defun createDocumentDictionary(directory-name)
  (let ((id 0))
    (setq *documents* (make-hash-table))
    (mapcar (lambda (x) 
              (setf (gethash id *documents*) 
                    (make-document 
                     :path x 
                     :document-vector nil))
              (setq id (+ 1 id)))
            (directory directory-name))))



;form: dictionary mit keywords mit dem keyword-namen [symbol] als key und entries in der form (docID type content)
(defun process-keyword-list (keyword-list docID)
  (let ((current) (key) (entry) (type) (content))
    (do* ((k-list keyword-list (cdr k-list))
          (k (car k-list) (car k-list))) ;iterate over keyword list, k is the whole term!
         ((equal k-list nil) nil)
      (setq k (subseq k 1 (- (length k) 1))) ;dont want the brackets
      
      (setq current (split-name-content k)) 
      (setq key (read-from-string (first current)))
      (setq content (read-from-string (second current)))
      (setq type (type-of content))



      (cond ((equalp key 'datum) 
             (setf (document-datum (gethash docID *documents*)) content))
            ((equalp key 'absender) 
             (setf (document-absender (gethash docID *documents*)) content)))  
      (setq entry 
            (make-keyword-entry 
             :doc-id docID 
             :keyword-type type 
             :content content)) 
      (if (gethash key *keyword-dict*)
          (setf (gethash key *keyword-dict*) (cons entry (gethash key *keyword-dict*))) ;already existing ;HIER sortiert einfuegen
        (setf (gethash key *keyword-dict*) (list entry)))))) ;new entry for keyword



;returns all keys from  dictionary sorted alphabetically (+ freitext as special keyword)
(defun getKeys (dict)
  (let ((keylist '()))
    (loop for key being the hash-key of dict do 
          (setq keylist (cons key keylist)))
    (cons 'FREITEXT (sort keylist 'string<))))



(defun sort-keyword-list()
  (let ((entry-list))
    (loop for key being the hash-key of *keyword-dict* do
          (setq entry-list (gethash key *keyword-dict*))
          (stable-sort entry-list #'(lambda (x y)
                       (< (keyword-entry-doc-id x) (keyword-entry-doc-id y)))))))




;has to do all init steps, called when directory selected
(defun onSelected (directory-name)
  (let ((current-doc))
    (setf (capi:button-enabled select-button) nil)
    (setq *results* '()) ;reset results because new directory
    (createDocumentDictionary directory-name)
    (loop for docID being the hash-key of *documents* do 
          (setq current-doc (split (readFileInLines (document-path (gethash docID *documents*)))))
          (process-keyword-list (first current-doc) docID)
          (setq *free-text* (cons (list docID (second current-doc)) *free-text*))
          (add-to-vocabulary (second current-doc)))
    (sort-keyword-list)
    (create-term-dictionary)
    (create-document-vectors *free-text*)
    (getKeys *keyword-dict*)))



  (let ((current-doc))
    (setf (capi:button-enabled select-button) nil)
    (setq *results* '()) ;reset results because new directory
    (createDocumentDictionary directory-name)
    (loop for docID being the hash-key of *documents* do 
          (setq current-doc (split (readFileInLines (document-path (gethash docID *documents*)))))
          (process-keyword-list (first current-doc) docID)
          (setq *free-text* (cons (list docID (second current-doc)) *free-text*))
          (add-to-vocabulary (second current-doc)))
    (sort-keyword-list)
    (create-term-dictionary)
    (create-document-vectors *free-text*)
    (getKeys *keyword-dict*)))



;;;;Keyword-Search-----------------------------------------------------------------------


;logical procession of query
(defun verarbeite-query (selection-list text)
  (let ((entry-list) (entry) (type) (content) (result-list '()) (keyword-result) (tmp))
    (cond  ((> (length selection-list) 0) ;only react if user selected something
            (mapcar (lambda (keyword) ;iterate over keywords
                      (print keyword)
                      (setq entry-list (gethash keyword *keyword-dict*))
                      (setq keyword-result '()) ;contains all documents in which the current keyword contains specified text
                      (mapcar (lambda (entry)  ;iterate over all entries for current keyword
                                (setq docID (keyword-entry-doc-id entry))
                                (setq type (keyword-entry-keyword-type entry))
                                (setq content (keyword-entry-content entry))
                                (cond ((and (equal type 'cons) (recursive-list-search text content)) ;different search procedures according to type
                                       (setq keyword-result (cons docID keyword-result)))
                                      ((and (equal type 'simple-base-string) (string-search text content)) ;union is necessary if keyword occurs multiple times in document (e.g. different cases)
                                       (setq keyword-result (union (list docID) keyword-result))) 
                                      ((and (equal type 'fixnum) (num-search text content))
                                       (setq keyword-result (union (list docID) keyword-result)))))
                              entry-list)
                      (setq result-list (cons keyword-result result-list)))
                    selection-list)

            
                   (if (equal (capi:choice-selected-item radio-buttons) button-or) 
                       (setq result-list (connect-or result-list)) ;connect inner term with and/or
                     (setq result-list (setq result-list (connect-and result-list))))


            (cond ((not (null (member 'NOT (capi:choice-selected-items not-operator-panel))))  ;if selected, surround with not
                   (setq result-list (negate result-list)))))) result-list)) 


(defun recursive-list-search (text content)
  (let ((elem) (found nil))
    (cond ((null (car content)) nil)
           (t (setq elem (car content)) ;erstes element durchsuchen
              (cond ((equal (type-of elem) 'simple-base-string) (setq found (string-search text elem)))
                    ((equal (type-of elem) 'fixnum) (setq found (num-search text elem)))
                    ((equal (type-of elem) 'cons) (setq found (recursive-list-search text elem)))) ;sublisten auch durchsuchen
              (if found t (recursive-list-search text (cdr content)))))))
          
              


(defun string-search (text content)
  (search text content :test 'equalp))




(defun num-search (text content)
  (let ((num (ignore-errors (read-from-string text))))
    (cond ((numberp num) (= num content))
          (t (cond ((equalp text "null") (setq num 0))
                   ((equalp text "eins") (setq num 1))
                   ((equalp text "zwei") (setq num 2))
                   ((equalp text "drei") (setq num 3))
                   ((equalp text "vier") (setq num 4))
                   ((equalp text "fünf") (setq num 5))
                   ((equalp text "sechs") (setq num 6))
                   ((equalp text "sieben") (setq num 7))
                   ((equalp text "acht") (setq num 8))
                   ((equalp text "neun") (setq num 9))
                   ((equalp text "zehn") (setq num 10))
                   ((equalp text "elf") (setq num 11))
                   ((equalp text "zwölf") (setq num 12)))
             (if (numberp num) (= num content))))))




(defun connect-and (result-list)
 (let ((and-res))
  (setq result-list (sort result-list '> :key 'length))
  (setq and-res (car result-list))
  (setq result-list (cdr result-list))
  (mapcar (lambda (x) 
            (setq and-res (intersection and-res x))) result-list)
  and-res))
    


(defun connect-or (result-list)
  (let ((or-res))
    (setq or-res (car result-list))
    (setq result-list (cdr result-list))
    (mapcar (lambda (x)
              (setq or-res (union or-res x))) result-list)
    or-res))
    

;only one list because and/or operation before negation
(defun negate (result)
  (let ((all-docs '()))
    (loop for id being the hash-key of *documents* do
          (setq all-docs (cons id all-docs)))
    (setq all-docs (set-difference all-docs result))
    all-docs))


                        
