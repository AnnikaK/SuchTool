\chapter{Implementierung}

In diesem Kapitel wird beschrieben, auf welche Weise das System zur Informationssuche in einem Dokumentenarchiv basierend auf Textinhalt sowie Metadaten durch Kombination von booleschem Retrieval und dem Vektorraummodell in der Programmiersprache Lisp realsisiert wurde.

\section{Teilweise strukturierte Dokumente}
Besonderheit der Problemstellung ist das Vorliegen der Dokumente in semistrukturierter Form (siehe \ref{Problemstellung}). 
Dies erfordert das Lösen zweier Teilprobleme: Zum einen die Metadatensuche und zum anderen die Freitextsuche. Beides wurde getrennt gelöst, da die Suchen unterschiedliche Anforderungen besitzen.\\
Bevor erklärt wird, wie die beiden Verfahren jeweils realisiert wurden, ist es wichtig, zunächst eine Vorstellung zu haben, wie die zu durchsuchenden Dokumente des Archivs beschaffen sind, weshalb Abbildung \ref{example} ein Beispiel zeigt. Dieses zeigt, dass jedes Dokument spezifische Eigenschaften besitzt, die durch Attributnamen und Attributwert dargestellt sind. Beispielsweise ist \glqq datum\grqq{} ein Attributname und \glqq("Wed, 22 Jun 2017 07:47:51 +0200")\grqq{} ein Attributwert. \\
 Die Gesamtheit aller Attribute eines Dokuments bildet den Metadatenteil. Darauf folgt der unstrukturierte Freitextpart.
\begin{lstlisting}[language=lisp, caption={Beispieldokument}
\label{example},
language=lisp]


(absender ("<MaxMuster@muster-mail.de>"))
(Betreff (" Umfrage"))
(datum ("Wed, 22 Jun 2017 07:47:51 +0200"))
(anzahlAnhaenge 0)
(Termin nil)

(ABSENDER-NAME "Max_Muster")
(ABSENDER-MAIL-ADRESSE "MaxMuster@muster-mail.de")
(EMPFAENGER ("doe>> John Doe"))
(EMPFAENGER-MAIL-ADRESSEN ("johnd@muster-mail.de"))
(BETREFF "Umfrage")
(EMAIL-TYP "sent")
(QUELLBOXART "SENT")

Hallo John,

ich werde dir die Umfragenformulare schnellstmöglich per Post 
zukommen lassen.


Viele Grüße
Max Muster

\end{lstlisting}

In der Praxis enthalten die Dokumente oft weitaus mehr Attribute, deren Inhalt sich auch über mehrere Zeilen erstrecken kann, sowie Kommentare, welche vom System als Freitext interpretiert werden. 
Bei diesem Beispiel handelt es sich zwar um eine E-Mail, die Attribute können jedoch inhaltlich vollkommen unterschiedlich ausfallen. Allen Dokumenten gemeinsam ist jedoch die 
grundlegende Struktur aus \ref{struct}.

\begin{lstlisting}[language=lisp, caption=Dokumentstruktur,label={struct}]
(Attrubutename_1 Attributwert_1)
....
(Attributname_n Attributwert_n)

Freitext

\end{lstlisting}



\section{Vorverarbeitung}
Beim Starten des Programms werden einige Schritte Initialisierungsschritte ausgeführt, die im folgenden Abschnitt beschrieben werden.

\subsection{Erstellen des Dokument-Dictionaries}
Zunächst wird das Dokument-Dictionary, welches intern durch eine Hash-Table realisiert wurde, da dies in Lisp einem Dictionary am nächsten kommt, erstellt, indem zu jedem Dokument die folgenden Punkte erfasst werden:
\begin{itemize}
	\item \textit{docID}: Das Zuweisen einer einmaligen \textit{doc-ID} in Form eines fortlaufenden Integer-Wertes. Diese \textit{doc-ID} ist der Hash-Key für dieses Dokument im Dokument-Dictionary.
	\item Dateipfad
	\item Dokumentvektor (zu Beginn noch nicht initialisiert). Dateipfad und Dokumentvektor bilden in einem Struct zusammengefasst den Wert zur \textit{docID}.
	\item Datum: Optionale Information, die zur verbesserten Ergebnisanzeige dient.
	\item Absender: ebenfalls optionale Information, die nur der Ergebnisanzeige dient.
\end{itemize}

Die  letzten beiden Punkte können entfallen, da nicht alle Dokumente diese Metadaten beinhalten, insbesondere falls es sich nicht um E-Mails handelt. Das System wurde bewusst flexibel gehalten, um auch andere Dateien verarbeiten zu können. \\
Abbildung \ref{docs} zeigt den Aufbau eines Eintrags im Dokument-Dictionary.
\begin{figure} [http]
	
	\centering
	\includegraphics[width=1\textwidth]{images/docDict.png}
	\caption{Struktur für einen Eintrag im Dokument-Dictionary. Die Einträge Datum und Absender können, falls nicht existent, auch leer bleiben. Im rot markierten Bereich werden später die Dokumentvektoren eingetragen. (Eigene Abbildung).}
	\label{docs}
	
\end{figure}

\subsection{Verarbeiten der Dokumente}
Anschließend wird über alle Dokument-Einträge iteriert, um die folgenden Schritte auszuführen:
\begin{enumerate}
	\item Aufteilen in Metadaten und Freitext
	\item Verarbeiten der Metadaten
	\item Verarbeiten des Freitextes
\end{enumerate}

Es stellt sich die Frage, was in den letzten beiden Punkten geschieht.

\subsubsection{Verarbeiten der Metadaten}
Die Metadaten werden zunächst in Attributname und Attributwert zerlegt, um sie weiterverarbeiten zu können. \\
Für die Metadatensuche wurde boolesches Retrieval (siehe Kapitel \ref{bool}) eingesetzt, da ein Attribut in einem Dokument entweder auftritt oder nicht, d.h. hier liegen klar definierbare Bedingungen vor. \\
Allerdings muss zusätzlich zum Auftreten noch geprüft werden, ob der Attributwert mit der Suchanfrage übereinstimmt bzw. Teile der Anfrage beinhaltet. \\
Um dies zu lösen, wurde auf eine modifizierte Form des klassischen Implementierungsansatzes für boolesches Retrieval, der invertierten Liste (siehe Abschnitt \ref{inverted}), zurückgegriffen, wobei eine Term-Inzidenz-Matrix als Datenstruktur von vornherein aufgrund des zu hohen Speicherbedarfs ausgeschlossen wurde. \\
In diesem Verarbeitungsschritt wird eine Hash-Table erstellt, welche die
Attributnamen als Keys und als Wert die folgenden Elemente, zusammengefasst in einem Struct, besitzt:
\begin{itemize}
	\item \textit{docID}: Eindeutiger Index des Dokuments, in dem das Attribut auftritt. Dieser gehört standardmäßig in die invertierte Liste.
	\item Typ: Dieser Eintrag gibt an, von welchem Typ der Attributwert ist, da dies über die Art der Suche darin entscheidet.
	\item Inhalt: Enthält den Attributwert. Dieser ist in der Regel so klein, dass er problemlos darin gespeichert werden kann und im Gegensatz zum Freitext keine weitere Verarbeitung erfordert. Dies würde nur unnötig Speicher belegen.
\end{itemize}

Zur Veranschaulichung der modifizierten invertierten Liste zeigt Abbildung \ref{m} diese anhand einiger Beispiel-Attribute. \\
Das Speichern der Informationen in einem Struct bietet den Vorteil, dass auf diese über den Slot-Value gezielt zugegriffen werden kann, anstatt über Listen iterieren zu müssen, was Effizienzeinbußen zufolge hätte. \\
Hierbei sei noch angemerkt, dass beim Speichern der Attributnamen Groß- und Kleinschreibung keine Rolle spielt, d.h. für die Keywords \glqq absender \grqq und \glqq ABSENDER \grqq wird nur ein Hash-Key angelegt. Kommen beide Keywords innerhalb eines Dokuments vor, gibt es unter dem entsprechenden Hash-Key zwei verschiedene Einträge mit der gleichen \textit{docID}, aber unterschiedlichen Inhalten. Das Ignorieren von Groß- und Kleinschreibung wird in diesem System im Allgemeinen angewendet, um möglichst fehlertolerant gegenüber abweichenden Nutzereingaben zu sein bzw. um auch Wörter, die sich nur durch Groß- und Kleinschreibung vom Suchbegriff unterscheiden, als relevante Treffer zu erkennen.

%MERGE!!!

\begin{figure} [http]
	
	\centering
	\includegraphics[width=1\textwidth]{images/mil.png}
	\caption{Modifizierte invertierte Liste zur Realisierung der Metadatensuche mittels Structs der Form (docID, Typ, Inhalt) (Eigene Abbildung).}
	\label{m}
	
\end{figure}

\subsubsection{Verarbeiten des Freitextes}
Für die Freitextsuche wurde das Vektorraummodell (siehe Kapitel \ref{vector}) gewählt, da dieses Teiltreffer sowie ein Ranking der Ergebnisse ermöglicht.  

Hierfür muss zunächst das Vokabular bestimmt werden, was wie folgt abläuft:



\begin{itemize}
	\item Es wird über eine Liste aller Freitexte iteriert.
	\item Jeder Freitext wird in seine Terme zerlegt. Hierbei wurde auf eine Lemmatisierung (siehe Abschnitt \ref{lemmatisierung}) verzichtet, da dies den Rahmen der Arbeit sprengen würde. Zur zeilenweise Zerlegung der Texte wurde das Package split-sequence verwenedet (\cite{Ionescu:16}).
	\item Für jeden Term wird geprüft, ob er schon bekannt ist oder nicht. Falls nicht, wird er der Vokabularliste hinzugefügt, vorausgesetzt es handelt sich nicht um ein deutsches oder englisches Stoppwort.
\end{itemize}

Stoppwörter (siehe Abschnitt \ref{stop}) wurden bewusst aus dem Vokabular entfernt, um Speicherplatz zu sparen und die Suche zu beschleunigen. Andernfalls können Anfragen wie \textit{ Freitext = \glqq summary of the first chapters \grqq{}} aufgrund des \glqq of the \grqq{} zu erheblichen Problemen führen, da hierbei meistens alle Dokumente infrage kommen. Die englischen Stoppwörter, welche in der Implementierung verwendet wurden, stammen von der Website \cite{webtools:13}. Die verwendete deutsche Stoppwortliste stammt aus \cite{Kohlfuerst:09} und enthält analog deutsche Begriffe wie \glqq der, die, das, und\grqq{} etc., welche nichts über den Textinhalt aussagen und darum ignoriert werden können. \\
Nachdem alle Terme bekannt sind, werden diese indexiert:

\begin{itemize}
	\item Es wird ein Term-Dictionary, realsiert durch eine Hash-Table, angelegt.
	\item Für jeden Term der Vokabularliste wird ein Eintrag der Form (Index,idf=0) angelegt, wobei der Index ein fortlaufeneder Integer-Wert ist und der idf-Wert noch zu berechnen ist.
\end{itemize}

\begin{figure} [http]
	
	\centering
	\includegraphics[width=0.5\textwidth]{images/termDict.png}
	\caption{Struktur für einen Eintrag im Term-Dictionary. Der Index gibt die Position im Dokumentvektor an (Eigene Abbildung).}
	\label{terms}
\end{figure}

Nach dem abgeschlossenen Anlegen kann das Term-Dictionary mit Einträgen in der in Abbildung \ref{terms} gezeigten Struktur gefüllt werden. Beim Befüllen wird über alle Freitexte iteriert und es werden pro Freitext, d.h. pro Dokument, die folgenden Schritte ausgeführt: \\
\begin{itemize}
	\item Anlegen eines Dokumentvektors, realisiert mittels Hash-Table, welcher die Term-Indizes als Keys und deren tf-idf-Gewichte als Werte besitzt.
	\item Tritt ein Term zum ersten Mal in der Sammlung, wird der idf-Slot im Term-Dictionary auf 1 gesetzt.
	\item Tritt ein Term zum ersten Mal im Dokument auf und existiert bereits in der Sammlung, wird der idf-Wert im Term-Dictionary um 1 erhöht.
	\item Beim ersten Auftreten im Dokument wird der Eintrag im Dokumentvektor auf die Termhäufigkeit 1 gesetzt. Die Position im Vektor ist durch Zugriff auf den Index des Terms (gespeichert im Term-Dictionary) bekannt.
	\item Für jedes erneute Auftreten im Dokument wird die Termhäufigkeit im Dokumentvektor um 1 erhöht.
	\item Ist der Freitext des aktuellen Dokuments vollständig verarbeitet, kann der bereits angelegte Eintrag an der entsprechenden Stelle im Dokument-Dictionary (d.h. der Slot \glqq Dokumentvektor\grqq{} im Hash-Eintrag mit der passenden \textit{docID})) mit dem hier erstellten Dokumentvektor initialisiert werden.
\end{itemize}
Noch enthalten die idf-Slots im Term-Dictionary die Dokumenthäufigkeiten statt der tatsächlichen idf-Werte.
Nun erfolgt deren Umrechnung in den idf-Wert nach Formel \ref{idfb}.\\
Da die idf-Werte jetzt feststehen können die  Termäuhfigkeiten in den Dokumentvektoren in die entsprechenden tf-idf-Werte nach Formel \ref{tfidfc} umgerechnet werden. 
An dieser Stelle stehen die Dokumentvektoren fest und können zur Verrechnung mit dem Anfragevektor verwendet werden. \\
Durch das Realisieren der Vektoren als Hash-Tables entfallen leere Einträge, die nur unnötig Speicher belegen. Ein fehlender Eintrag wird als Gewicht 0 interpretiert, sodass dies kein Problem bei der Ähnlichkeitsberechnung darstellt. 


\section{Die Suche}
Nachdem die Initialisierungsschritte ausgeführt wurden, kann der Nutzer die Suche starten. Er sieht auf der Benutzeroberfläche, welche Attribute ihm als Suchbereiche zur Verfügung stehen. Das Attribut \glqq Freitext \grqq{} ist hierbei immer vorhanden. In diesem Abschnitt wird die interne Realisierung der Suche erklärt. 

\subsection{Metadatensuche}
Lautet die Anfrage beispielsweise $Absender=klaus$, wird auf die modifizierte invertierte Liste über den Hash-Key $Absender$ zugegriffen. Anschließend wird über alle darin gespeicherten Structs iteriert, wobei zunächst der Typ des Inhalts abgefragt wird. Dieser entscheidet über die Art der Suche:
\begin{enumerate}
	\item \textbf{String}: Der Attributwert wird mit der vordefinierten Lisp-Funktion search durchsucht. Die Suche ist erfolgreich, wenn die gesuchte Zeichenkette an einer beliebigen Stelle im Attributwert auftaucht.
	\item \textbf{Number}: Ist der Inhalt eine Zahl, wird die Suchanfrage (die stets als String übergeben wird) wenn möglich zum Datentyp Number konvertiert. Hierbei sind ausgeschriebene Zahlen von null bis zwölf auch konvertierbar. Ist kein Konvertieren möglich, schlägt die Suche sofort fehl, da der Inhalt nicht zur Anfrage passen kann.
	\item \textbf{Liste}: Eine Liste (Datentyp Cons in Lisp) wird rekursiv durchsucht, um alle darin enthaltenen Elemente typspezifisch zu durchsuchen, d.h. darin enthaltene Strings, Zahlen und Unterlisten.
\end{enumerate}
Liegt ein Treffer vor, wird die\textit{docID} als Resultat der Ergebnisliste hinzugefügt. \\
Hierbei kann es sein, dass pro Teilanfrage mehrere Metadatensuchen durchgeführt werden, da der Nutzer die Anfrage für verschiedene Attribute gleichzeitig stellt. \\
Dann hat jedes Attribut seine eigene Ergebnisliste, die gemäß booleschem Retrieval mit Mengenoperationen verrechnet werden: Ist $AND$ ausgewählt, wird aus den Listen der Durchschnitt gebildet, bei $OR$ die Vereinigung. \\
Nun liegt das finale Ergebnis für die Metadatensuche der Teilanfrage vor - es sei denn, der Nutzer hat $NOT$ ausgewählt. Dann wird die Differenz zwischen den Dokumenten des Archivs und dem ermittelten Ergebnis zurückgegeben.

\subsection{Freitextsuche}
\subsection{Erstellen des Query-Vektors}
Für die Freitextsuche muss die Anfrage erst in einen Vektor umgewandelt werden. Auch hier wird eine Hash-Table für das Anlegen des Query-Vektors verwendet. \\
Für jeden Term wird dessen Index im Term-Dictionary abgefragt. Vorausgesetzt, der Term existiert im Vokabular, wird dieser Index zum Key und die Termhäufigkeit in der Anfrage zum Wert. Anschließend wird die Termhäufigkeit durch den idf-Wert dividiert, sodass der Query-Vektor die finalen tf-idf-Gewichtungen enthält.\\
Damit wird die Anfrage genau wie ein Dokument behandelt, mit dem einzigen Unterschied dass bestimmte Terme eventuell nicht im Vektor eingetragen und gewichtet werden, da diese im Archiv nicht vorkommen und darum für die Suche irrelevant sind.\\
Abbildung \ref{query} veranschaulicht das Erstellen eines Query-Vektors anhand eines Beispiels.
\subsubsection{Finden der Resultate}
Das Bestimmen der Suchergebnisse für die Freitextsuche läuft wie folgt ab:

\begin{itemize}
	\item Es wird über alle Dokumente im Dokument-Dictionary iteriert und auf deren Dokument-Vektoren zugegriffen
	\item Es wird das Cosinus-Maß (siehe Formel \ref{cos}) zur Berechnung der Ähnlichkeit zwischen Dokument- und Query-Vektor verwendet
	\item Das Ergebnis ist der Score, welcher gemeinsam mit der \textit{docID} der Ergebnisliste hinzugefügt wird.
	\item Diese wird basierend auf dem Score sortiert, sodass sich die ähnlichsten Dokumente vorne befinden.
\end{itemize}

\begin{figure} [http]
	
	\centering
	\includegraphics[width=0.5\textwidth]{images/Umwandlung.png}
	\caption{Beispiel für Umwandlung einer Anfrage in einen Query-Vektor. \glqq Kontaktadresse\grqq{} hat den Index 3, \glqq Seminar\grqq{} den Index 123. Mai kommt im Archiv nicht vor, darum wird der Term nicht vermerkt. Alle Indizes ungleich 3 und 123 sind als mit 0 gewichtet zu interpretieren (Eigene Abbildung).}
	\label{query}
\end{figure}



\section{Verrechnung der Suchergebnisse}
Die Resultate der Metadatensuche und der Freitextsuche müssen miteinander kombiniert werden, wobei der Score problematisch ist, da die Freitextergebnisse einen besitzen, die Metadaten-Resultate jedoch nicht. \\
Das Kombinieren von beiden Suchen wurde wie folgt realisiert:
\begin{itemize}
	\item Jedes Dokument in der Metadaten-Ergebnisliste erhält den Score 1.
	\item Ist $AND$ ausgewählt, wird der Durchschnitt beider Suchen gebildet und Metadaten-Score sowie Freitextscore werden addiert.
	\item Ist $OR$ ausgewählt, wird die Vereinigung beider Suchen gebildet und Metadaten-Score sowie Freitextscore der Dokumente, die in beiden Ergebnislisten vorkommen, werden addiert.
\end{itemize}
Da die Anfrage beliebig tief geschachtelt werden kann, ist es möglich, dass sich der Score eines Dokuments weiter erhöht: \\
Das Gesamtergebnis wird mit jeder neuen Teilanfrage auf dieselbe Weise verrechnet, wie es soeben beschrieben wurde. \\
Demnach erhält ein Dokument, dass für 5 Teilanfragen einen Treffer in der Metadatensuche lieferte, den Score 5. Handelt es sich hingegen um einen nicht ganzzahligen Wert, z.B. 5,27, kamen noch Treffer in der Freitextsuche hinzu. \\
Aufgrund des Rankings kann der Nutzer in etwa abschätzen, wie wichtig ein Dokument für seine Anfrage war und auch, auf welche Weise der Treffer zustande kam.



