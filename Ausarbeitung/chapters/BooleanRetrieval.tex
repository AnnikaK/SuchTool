\chapter{Boolesches Retrieval}
\label{bool}
Dieses Kapitel stellt das klassische Information-Retrieval-Verfahren boolesches Retrieval (engl. boolean retrieval) vor. \\

\section{Eigenschaften des Verfahrens}
Boolesches Retrieval überprüft Dokumente auf das Zutreffen einer bestimmten Bedingung. 
Somit erfolgt lediglich die Unterteilung in passende Dokumente und jene, welche diese Bedingung nicht erfüllen. Eine darüber hinausgehende Bewertung der Ergebnisse findet nicht statt, was zu einer ungeordneten Ergebnismenge führt, die in keine Rangfolge gebracht werden kann (\cite{Ferber:03}, S.33). Das fehlende Ranking ist ein häufiger Kritikpunkt des Verfahrens.\\
 
 
\section{Funktionsprinzip}
Boolesches Retrieval basiert auf Mengenoperationen, weshalb den Dokumenten Mengen zugeordnet werden, die jeweils durch bestimmte Attribute charakterisiert sind. Wenn von Dokumenten gesprochen wird, ist hiermit die Einheit gemeint, auf der das Retrieval stattfindet. Es kann sich hierbei um kleine Textmemos, aber auch um ganze Buchkapitel handeln (\cite{Manning:08}, S.4).

\subsection{Attribut}
Ein Attribut ist eine Abbildung, welche jedem Dokument einen Wert für dieses Attribut zuordnet. Die Abbildung erzeugt somit Attribut-Wert-Paare, was in Formel \ref{attr} gezeigt wird. 

\begin{equation}
\label{attr}
t: D \rightarrow T, t(d) = t_i
\end{equation}


Hierbei bezeichnet $t$ die Abbildung (d.h. das Attribut), $D$ die Menge aller Dokumente und $T$ den Wertebereich des Attributs $t$. \\
 Der Attributwert $t_i$ mit $t_i \in T$ und $i \in \mathbb{N}$ wird durch die Abbildung $t$ dem Dokument $d \in D$ zugeordnet. \\

\subsection{Anfragen}
 \label{formelzeugs}
\subsubsection{Elementare boolesche Anfrage}
Ein Attribut-Wert-Paar wird auch als elementare boolesche Anfrage bezeichnet. Bei der elementaren booleschen Anfrage  $(t,t_1)$ werden zum Beispiel alle Dokumente gesucht, deren Attribut $t$ den Wert $t_1$ annimmt. 
Die Ergebnismenge $D_t,_{t_i}$ für eine Anfrage $(t,t_i)$ kann demnach wie in Formel \ref{ergMen} charakterisiert werden. 

\begin{equation}
\label{ergMen}
D_t,_{t_i} =  \{d \in D | t(d) = t_i\} \\
\end{equation}

\subsubsection{Verknüpfung}
Beim logischen Verknüpfen mehrerer elementarer boolescher Anfragen werden abhängig vom jeweiligen booleschen Operator bestimmte Mengenoperationen auf den Ergebnismengen der elementaren Anfragen ausgeführt. 
Die möglichen booleschen Operatoren sind hierbei $AND$, $OR$ und $NOT$.
$(t,t_1)$ $AND$ $(s,s_1)$ bedeutet, dass alle Dokumente gesucht sind, bei denen sowohl $t(d) = t_1$ als auch $s(d) = s_1$ gilt. Die erforderliche Mengenoperation ist deshalb der Durchschnitt aus den beiden Ergebnismengen, was in Formel \ref{intersection} gezeigt wird.

\begin{equation}
\label{intersection}
D_t,_{t_1} \cap D_s,_{s_1}
\end{equation}


Wird hingegen der Operator $OR$ verwendet, wird die Mengenoperation Vereinigung benötigt (siehe Formel \ref{union}), da alle Dokumente mit  $t(d) = t_1$ oder $s(d) = s_1$ gesucht sind. \\


\begin{equation}
\label{union}
D_t,_{t_1} \cup D_s,_{s_1}
\end{equation}


Außerdem kann der unäre Operator $NOT$ verwendet werden, welcher das Komplement der Ergebnismenge erzeugt. Für die Anfrage $NOT$ $(t,t_1)$ muss erst die Menge aller Dokumente bestimmt werden, bei denen $t(d) = t_1$ zutrifft, um diese anschließend von der Gesamtmenge aller Dokumente abzuziehen. Dies wird in Formel \ref{minus} dargestellt.


\begin{equation}
\label{minus}
D \setminus D_t,_{t_1}
\end{equation}



Da bei jeder Mengenoperation als Ergebnis wieder neue Mengen entstehen, lassen sich hierauf erneut die oben beschriebenen Operatoren anwenden. Auf diese Weise können Anfragen beliebig tief geschachtelt werden (\cite{Ferber:03}, S.34).

\section{Implementierungsansätze}
Im folgenden Abschnitt werden klassische Implementierungsansätze für boolesches Retrieval vorgestellt, mit denen sich die soeben beschriebenen Operationen realisieren lassen.

\subsection{Term-Dokument Inzidenz Matrix}
\label{matrix}
Eine mögliche Implementierung des booleschen Retrieval stellt die Umsetzung mittels einer Term-Dokument Inzidenz Matrix dar. 
In den Zeilen einer solchen Matrix werden die Terme eingetragen und in den Spalten die Dokumente bzw. deren \textit{docID}s. 
Tritt Term $t$ in Dokument $d$ auf, so lautet der Eintrag für $(t,d)$ in der Matrix 1. Alle Einträge für nicht vorkommende Terme sind hingegen mit einer 0 versehen. 
Abbildung \ref{abb0} zeigt ein Beispiel, wobei zu beachten ist dass die tatsächliche Anzahl an Termen und Dokumenten in einer Sammlung weitaus größer ausfällt. \\
Eine Term-Dokument Inzidenz Matrix besitzt den gravierenden Nachteil, dass sie unnötig Speicherplatz verbraucht, da sehr viele Einträge der Matrix eine 0 enthalten. Gerade bei sehr großen Sammlungen bzw. Dokumenten ist dieser Implementierungsansatz aufgrund des limitierten Speicherplatzes nicht realisierbar.




\begin{figure} [hbtp]
	\centering
	\includegraphics[width=1\textwidth]{images/matrix.png}
	\caption{Term-Dokument Inzidenz Matrix. Die Zeilen enthalten die Terme, die Spalten die \textit{docIDs} der Dokumente. Alle Einträge mit einer 0 sind leere Einträge (Eigene Abbildung).}
	\label{abb0}
\end{figure}


\subsubsection{Verarbeitung einer Anfrage mittels Matrix}
Um eine Anfrage wie $Kontaktadresse$ $AND$ $Seminar$ $AND$ $Termin$ mithilfe einer Matrix zu verarbeiten, werden einfach die entsprechenden Zeilen entnommen und bitweise logisch verknüpft, was für die obige Anfrage und die Matrix aus Abbildung \ref{abb0} wie folgt aussieht: \\\\
0110001 AND \\
1010100 AND\\
1110000\\
----------- \\
0010000 \\\\
Demnach wird das Dokument mit der \textit{docID} 3 zurückgegeben. Analog funktioniert  die \textit{OR}-Verknüpfung: \\\\
0110001 OR \\
1010100 OR\\
1110000\\
----------- \\
1110101 \\\\

Dieses Beispiel führt zur Ergebnismenge $\{1,2,3,5,7\}$ (\cite{Manning:08}, S.4).



\subsection{Invertierte Liste}
\label{inverted}
In der Regel werden zur Implementierung des booleschen Retrieval invertierte Listen (engl. inverted lists) verwendet (\cite{Ferber:03}, S.36). 
Der Name basiert auf den darin gespeicherten invertierten Indizes, die deshalb als invertiert bezeichnet werden, weil sie vom Term zurück auf die Postion, in welcher der Term aufgetreten ist, schließen lassen.\\
In einer geeigneten Speicherstruktur, zum Beispiel einem Dictionary, werden zu jedem Term alle Dokumente gespeichert, in denen der Term auftritt, d.h. deren Indizes oder \textit{docIDs}. Hierbei ist anzumerken, dass hierfür tatsächlich jede geeignete Speicherstruktur verwendet werden kann, denn trotz des Namens muss es sich nicht um Listen handeln.
Abbildung \ref{abb1} zeigt ein Beispiel einer solchen invertierten Liste.
 Manche Implementierungen beinhalten neben der \textit{docID} noch zusätzliche Informationen wie die genaue Wortpostion im Dokument. \\
Das Verfahren ermöglicht sehr schnelle Zugriffe, ist allerdings speicherintensiv (\cite{Ferber:03}, S.36). Invertierte Listen stellen jedoch eine deutliche Verbesserung im Vergleich zu Term-Dokument Inzidenz Matrizen dar, da sie keine leeren Einträge enthalten.


\begin{figure} [hbtp]
	\centering
	\includegraphics[width=1\textwidth]{images/inverted_list.png}
	\caption{Invertierte Listen zu drei Beispieltermen. Jede invertierte Liste enthält die Dokumentindizes oder auch \textit{docID}s der Dokumente, in denen der jeweilige Term vorkommt (Eigene Abbildung).}
	\label{abb1}
\end{figure}


\subsubsection{Verarbeitung einer Anfrage mittels invertierter Liste}
Es stellt sich die Frage, wie eine boolesche Anfrage wie in Abschnitt \ref{formelzeugs} beschrieben mithilfe invertierter Listen umgesetzt werden kann. \\
\paragraph{Elementare Anfrage}
Angenommen, es liegt eine elementare boolesche Anfrage in der Form $(t,t_1)$ vor. Ist nach dem Vorkommen eines bestimmten Wortes gefragt, entspricht das Attribut $t$ dem Term des gesuchten Wortes, da  Term und Wort nicht zwangsläufig äquivalent sind (siehe Abschnitt \ref{lemmatisierung}). Da man auf dessen Vorkommen prüft, gelten für den Wertebereich $T = \{true, false\}$ und für den Attributwert $t_1 = true$. \\
Die Verarbeitung einer solchen elementaren Anfrage geht relativ einfach: Über den Termindex kann auf den Term schnell zugegriffen werden, vorausgesetzt dieser ist im Vokabular enthalten. Trifft dies zu, kann die zugehörige invertierte Liste als Resultat ausgegeben werden, da für alle darin enthaltenen Dokumente $t_1 = true$ gilt. \\
\paragraph{AND-Verknüpfungen}
Wie sieht nun die Verarbeitung aus, wenn mehrere elementare Anfragen miteinander verknüpft werden? Um dies zu beantworten, wird zunächst der $AND$-Operator betrachtet. Eine zusammengesetzte Anfrage liegt dann in der Form $(t,t_1)$ $AND$ $(s,s_1)$ vor, wie etwa in dem Beispiel $Kontaktadresse$ $AND$ $Seminar$, bei dem $t=Kontaktadresse, t_1=true$ sowie $s=Seminar, s_1=true$ gelten.
Dies bedeutet, dass alle Dokumente gesucht sind, in denen beide Terme auftauchen. \\
Hierzu wird der Durchschnitt aus den Ergebnismengen beider elementarer Anfragen gebildet, d.h. der Durchschnitt aus beiden invertierten Listen. Betrachtet man die Abbildung \ref{abb1}, so ist der Durchschnitt für $Kontaktadresse \cap Seminar$ gleich der Ergebnisliste $\{3,11\}$. \\



\paragraph{OR-Verknüpfungen}
Lautet die Anfrage hingegen $(t,t_1)$ $OR$ $(s,s_1)$ bzw. $Kontaktadresse$ $OR$ $Seminar$, so sind alle Dokumente gesucht, in denen entweder $t_1$, $s_1$ oder auch beide Terme vorkommen. 
Die zu verwendende Mengenoperation ist deshalb die Vereinigung  $D_{t,t_1} \cup D_{s,s_1}$ bzw. $Kontaktadresse \cup Seminar$, was bedeutet dass die invertierten Listen, die als Ergebnis für die beiden elementaren booleschen Anfragen zurückgeliefert werden, vereinigt werden.
Bezogen auf Abbildung \ref{abb1} lautet die Ergebnismenge für das Beispiel $Kontaktadresse$ $OR$ $Seminar$ $\{1,2,3,5,7,9,11,15,22,25,30,32\}$.
Bei beiden Listenoperationen werden die Indizes in den Ergebnislisten sortiert und Duplikate entfernt (\cite{Manning:08}, S.11). 

%Zur Vereinigung zweier sortierter Listen bietet sich der bekannte und effiziente Merge-Algorithmus an, der eine Laufzeit von $O(n log n)$ besitzt. In leicht abgewandelter Form lässt sich hiermit auch der Durchschnitt zweier sortierter Listen mit gleicher Laufzeit bilden.


\paragraph{AND NOT-Verknüpfung}
Da es sich bei $NOT$ um einen unären Operator handelt, könnte dieser theoretisch alleine auftreten. 
Eine Anfrage der Form $NOT$ $Seminar$ kann jedoch sehr viel Laufzeit kosten, wenn das Archiv viele Dokumente enthält: Es muss über die gesamte Sammlung iteriert und für jedes Dokument geprüft werden, ob es in der invertierten Liste für den Term Seminar auftaucht. Der alleinstehende $NOT$-Operator ist aufgrund dessen so ineffizient, dass er bei den meisten booleschen Information-Retrieval-Systemen nur im Zusammenhang mit einem binären Operator zugelassen ist.
Da die Kombination $OR$ $NOT$ keinen Sinn macht, wenn ein Term ausgeschlossen werden soll, ist dieser Operator in der Regel ausschließlich $AND$. \\
Hierbei wird aus den beiden Listen die Differenz gebildet. Lautet die Anfrage beispielsweise $Kontaktadresse$ $AND$ $NOT$ $Seminar$, so werden aus der Ergebnisliste für Kontaktadresse alle Elemente entfernt, die in der Liste für Seminar enthalten sind (\cite{Henrich:08}, S.174). Ergebnismenge wäre demnach $\{2,7,9,15,22,25,30\}$, d.h. die Dokumente 3 und 11 wurden ausgeschlossen.\\


\paragraph{Komplex geschachtelte Ausdrücke}
Da sowohl Vereinigung als auch Durchschnitt eine neue Liste liefern, kann auf dieser wiederum jeder Operator angewandt werden, was eine beliebig tiefe Schachtelung erlaubt. Dieser Abschnitt erklärt, wie komplex geschachtelte Ausdrücke verarbeitet werden.\\
Im Falle von mehreren $AND$-Operatoren, wie etwa in der Suchanfrage $Kontaktadresse$ $AND$ $Seminar$ $AND$ $Termin$, ist es effizient, zunächst die einzelnen invertierten Listen aufsteigend nach deren Länge zu sortieren und dann von links nach rechts zu verarbeiten. So wird das nachfolgende $AND$ auf die Ergebnisliste des vorherigen Durchschnitts angewandt, was der folgenden Klammerung entspricht: \\
$(Seminar$ $AND$ $Termin)$ $AND$ $Kontaktadresse$ \\
Auf diese Weise werden die Listen, über die iteriert wird, möglichst klein gehalten. Besitzt die kleinste Liste beispielsweise die Länge eins, dann kann nach der ersten Iteration bereits abgebrochen werden, da zulässige Lösungen in allen drei Listen vorkommen müssen. \\
Bei mehreren $OR$-Operatoren werden die Ausdrücke analog von links nach rechts verarbeitet, wobei die Sortierung nach Länge hierbei keinen Vorteil bietet, da bei der Vereinigung zweier Listen ohnehin über alle Elemente iteriert werden muss. Die Verarbeitungsreihenfolge entspricht der folgenden Klammerung:
$(Kontaktadresse$ $OR$ $Seminar)$ $OR$ $Termin$ \\
Ist die Anfrage hingegen gemischt, wie etwa in dem Beispiel
($Kontaktadresse$ $OR$ $Seminar$) $AND$ ($Termin$ $OR$ $Seminar$), werden erst die inneren Ausdrücke ausgewertet und dann aus deren Ergebnislisten der Durchschnitt gebildet (\cite{Manning:08}, S.11).


\paragraph{Die Verarbeitung mehrerer Wörter}
Boolesches Retrieval kann auch mehrere zusammengehörige Wörter verarbeiten. 
Über die interne Verarbeitung hat der Nutzer jedoch keinerlei Einblick: Das Information-Retrieval-System kann so realisiert sein, dass es die aus den Wörtern der Anfrage isolierten Terme mit $OR$ verknüpft, es kann diese jedoch genauso gut mit $AND$ verbinden (\cite{Henrich:08}, S.171).\\






